{
    "cloud": {
        "tagDetails": {
            "name": "cloud",
            "description": "Manages cloud (object storage) targets"
        },
        "operations": []
    },
    "cluster": {
        "tagDetails": {
            "name": "cluster",
            "description": "Manages clusters, nodes, jobs, and cluster software\n",
            "x-ntap-long-description": "## Overview\nThese APIs enable you to perform a number of independent workflows, including:\n* Creating the cluster\n* Adding nodes to the cluster\n* Managing cluster configuration data (including name, version, NTP servers, name servers, and DNS domains)\n* Managing node configuration data (including node names, models, serial numbers, and HA group information)\n* Discovering the nodes on the cluster network that can be added to the cluster\n* Viewing and updating current and recent jobs\n* Updating the cluster software\n\n### Pre-Cluster APIs\nA few of the cluster APIs (namely, POST/OPTIONS on /api/cluster, GET/HEAD/OPTIONS on /api/cluster/nodes, and calls on /api/cluster/jobs) are allowed before the cluster is created.  These APIs support creation of the cluster and monitoring of its progress. Any other cluster API used before the cluster is created will fail.\n"
        },
        "operations": []
    },
    "networking": {
        "tagDetails": {
            "name": "networking",
            "description": "Manages physical and logical networking",
            "x-ntap-long-description": "## Overview\nThe ONTAP networking APIs enable reporting on networking information, such as IPspaces, interfaces, routes, ports, service policies and broadcast domains. Some can also be used to manage networking.\n<br/>\n---\n\n## IPspaces\nIPspaces enable you to configure a single ONTAP cluster so that it can be accessed by clients from more than one administratively separate network domain, even if those clients are using the same IP address subnet range. This allows for separation of client traffic for privacy and security.<br/>\n\nAn IPspace defines a distinct IP address space in which storage virtual machines (SVMs) reside. Ports and IP addresses defined for an IPspace are applicable only within that IPspace. A distinct routing table is maintained for each SVM within an IPspace, so that no cross-SVM or cross-IPspace traffic routing occurs.\n<br/>\n\n---\n\n## Ethernet\n### Broadcast Domains\nA broadcast domain is a set of ports which would all receive a broadcast packet that is sent from any of the ports.<br/>\n\nBy accurately representing the physical network with an ONTAP broadcast domain, ONTAP ensures that IP interfaces are able to migrate to appropriate ports in case of failure. ONTAP also ensures that characteristics, such as MTU, stay matched across all ports of the broadcast domain.<br/>\n\nA broadcast domain resides in an IPspace, and can be used by cluster-scoped or SVM-scoped IP interfaces in that IPspace. The scope of the broadcast domain's uniqueness is the IPspace it is in. You must create as many broadcast domains in an IPspace as there are IP subnets with interfaces in that IPspace.<br/>\n\nPorts are mapped to an IPspace by assigning the port's broadcast domain.\n\n### Ports\nA port is a physical or virtual Ethernet network device. Physical ports may be combined into Link Aggregation Groups (LAGs, or ifgrps), or divided into Virtual LANs (VLANs).<br/>\n\nThe GET and PATCH APIs are available for all port types. The POST and DELETE APIs are available for \"lag\" and \"vlan\" port types.<br/>\n\nA given port can host zero or more IP interfaces.<br/>\n\nA port exists in a broadcast domain and all ports within the same broadcast domain must have layer 2 network connectivity to one another. If a port within a broadcast domain goes down, any IP interfaces hosted by that port can fail over to other ports in the same broadcast domain.\n <br/>\n---\n\n## Fibre Channel\n\n### Interfaces\nFibre Channel (FC) interfaces are the logical endpoints for Fibre Channel network connections to an SVM. A Fibre Channel interface provides Fibre Channel access to storage within the interface's SVM using either Fibre Channel Protocol (FCP) or Non-Volatile Memory Express over Fibre Channel (NVMe over FC).<br/>\n\nThe Fibre Channel interface REST API allows you to create, delete, update and discover Fibre Channel interfaces and obtain status information for Fibre Channel interfaces.<br/>\n\nA Fibre Channel interface is created on a Fibre Channel port that is located on a cluster node. The Fibre Channel port must be specified to identify the location of the interface for a POST or PATCH that relocates an interface. You can identify the port by either supplying the node and port names or the port UUID.\n\n### Ports\nFibre Channel ports are the physical ports of Fibre Channel adapters on ONTAP cluster nodes that can be connected to Fibre Channel networks to provide Fibre Channel network connectivity. A Fibre Channel port defines the location of a Fibre Channel interface within the ONTAP cluster.<br/>\n\nThe Fibre Channel port REST API allows you to discover Fibre Channel ports, obtain status information for Fibre Channel ports, and configure Fibre Channel port properties.\n\n### Learn More\n* _Fibre Channel Logins_ found in both the _SAN_ and _NVMe_ sections. Fibre Channel logins represent connections formed by Fibre Channel initiators that have successfully logged in to ONTAP.\n\n---\n\n## IP\n### Interfaces\nAn interface (also referred to as a _LIF_ in ONTAP documentation) represents a network access point to a node in a cluster. In other words, an interface is essentially an IPv4 or IPv6 address with associated attributes.<br/>\n\nIP interfaces are configured on ports to send and receive communications over the network. The port that will host the interface can either be explicitly specified using node and/or port fields or implicitly specified using a broadcast domain.<br/>\n\nThe IPspace of the interface is required for cluster-scoped interfaces. The SVM owning the interface is required for SVM-scoped interfaces. These interfaces are in the SVM's IPspace.<br/>\n\nThe service policy of an interface defines what network services are provided by the interface.\n\n### Routes\nRoutes indicate which IPv4 or IPv6 gateway to use to communicate with hosts that are not on the local subnet. Typically, an IP interface (or LIF) can only use a gateway if it has the same address family and is in the LIF's subnet.<br/>\n\nIt is important that every gateway address belongs to a physical or virtual router that has connectivity to the specified destination network.<br/>\n\nSVM-scoped routes can only be used by IP interfaces of the specified SVM. Likewise, cluster-scoped routes can only be used by cluster-scoped IP interfaces in the specified IPspace.\n\n### Service Policies\nService policies are named groupings that define what services are supported by an IP interface. These include both built-in service policies (for example: default-data-files or default-management) and custom service policies.<br/>\n\nService policies are scoped to either an SVM or IPspace.\n<br/>\n---\n"
        },
        "operations": []
    },
    "svm": {
        "tagDetails": {
            "name": "svm",
            "description": "Manages storage virtual machines (SVMs)",
            "x-ntap-long-description": "## Overview\nStorage Virtual Machine (SVM) APIs enable you to manage SVMs and their attributes, including the configuration of the CIFS and NFS protocols, export policies, name mappings between CIFS and NFS users, and network services.\n<br/>SVMs contain data volumes and one or more network interfaces through which they serve data to the clients. SVMs securely isolate the shared virtualized data storage and network, and each SVM appears as a single dedicated server to the clients. Each SVM has a separate administrator authentication domain, and each SVM can be managed independently by its SVM administrator.\n<br/>In a cluster, SVMs facilitate data access. A cluster must have at least one SVM to serve data. Multiple SVMs can coexist in a single cluster without being bound to any particular node in the cluster. However, they are bound to the physical cluster on which they exist.\n<br/>SVMs with volumes can contain files and LUNs. They provide file-level data access by using NFS and CIFS protocols for the NAS clients, and block-level data access by using iSCSI and Fibre Channel (FC) (FCoE included) for SAN hosts. The volumes within each NAS SVM are related to each other through junctions and they are mounted on junction paths. These junctions present the file system in each volume. The root volume of the SVM resides at the top level of the namespace hierarchy; additional volumes are mounted to the SVM root volume to extend the namespace. As volumes are created for the SVM, the root volume of the SVM contains junction paths.\n<br/>The ONTAP REST APIs only expose data SVMs as an SVM. The information and configuration associated with the cluster and nodes are exposed from REST, but the cluster and nodes are not treated as if they are a type of SVM from REST APIs. Some APIs that expose both cluster-owned resources and SVM-owned resources from the same endpoint only return and support the \"svm\" sub-object for the resources that are within a data SVM. In those endpoints, the resources that are not in a data SVM do not return the \"svm\" sub-object. Generally, such endpoints have a \"scope\" attribute that returns either \"svm\" or \"cluster\" to identify the resource as either a cluster-level resource or one that is completely contained in a data SVM.\n"
        },
        "operations": []
    },
    "name-services": {
        "tagDetails": {
            "name": "name-services",
            "description": "Manages SVM name services such as LDAP, NIS, and DNS",
            "x-ntap-long-description": "## Overview\nONTAP uses name-services to obtain information about users and clients. This information is used to authenticate users accessing data on or administering the storage system, and to map user credentials in a mixed environment. If the user database is stored in NIS or LDAP servers, NIS and LDAP name services need to be configured in ONTAP.\nDNS is used for resolving the hostnames. ns-switch is used to configure the SVMs with sources to search for network information and the order in which to search them.\n"
        },
        "operations": []
    },
    "SAN": {
        "tagDetails": {
            "name": "SAN",
            "description": "Manages resources for storage area networks (SAN)",
            "x-ntap-long-description": "## Overview\n\nThe storage area network (SAN) endpoints and objects enable you to configure, provision, and manage SAN-related objects.\n\n<br/>\n---\n## Fibre Channel\n\n### Logins\nFibre Channel logins represent connections, formed by Fibre Channel initiators, that have successfully logged in to ONTAP. This represents the Fibre Channel login on which higher-level protocols, such as Fibre Channel Protocol (FCP) and Non-Volatile Memory Express over Fibre Channel (NVMe over FC), rely.<br/>\n\nThe Fibre Channel logins REST API provides information about active Fibre Channel logins.\n\n### WWPN Aliases\nA WWPN (world wide port name) is a unique 64-bit identifier for a Fibre Channel initiator. It is displayed as a 16-character hexadecimal value. SAN administrators may find it easier to identify Fibre Channel initiators using an alias, especially in larger SANs.<br/>\n\nThe WWPN alias REST API allows you to create, delete and discover aliases for WWPNs.\n\n### Services\nA Fibre Channel Protocol (FCP) service defines the properties of the Fibre Channel Protocol target for an SVM. There can be at most one FCP service for a given SVM. An SVM's FCP service must be created before FCP initiators can login to the SVM.<br/>\n\nThe Fibre Channel Proctocol (FCP) service REST API allows you to create, update, delete, and discover Fibre Channel Services for SVMs.\nFibre Channel interfaces are the logical endpoints for Fibre Channel network connections to an SVM.\n\n---\n## iSCSI\n\n### Credentials\nAn iSCSI credentials object defines the authentication credentials to be used between an iSCSI initiator and ONTAP. It identifies an authentication type, user names, and the passwords that must be used to authenticate a specific initiator.<br/>\n\nThe iSCSI credentials REST API allows you to create, update, delete, and discover iSCSI credential objects.\n\n### Services\nAn iSCSI service defines the properties of the iSCSI target for an SVM. There can be at most one iSCSI service for an SVM. An SVM's iSCSI service must be created before iSCSI initiators can login to the SVM.<br/>\n\nThe iSCSI service REST API allows you to create, update, delete, and discover iSCSI services for SVMs.\n\n### Sessions\nAn iSCSI session consists of one or more TCP connections that link an iSCSI initiator with an iSCSI target. TCP connections can be added and removed from an iSCSI session by the iSCSI initiator. Across all TCP connections within an iSCSI session, an initiator sees one and the same target. After the connection is established, iSCSI control, data, and status messages are communicated over the session.<br/>\n\nThe iSCSI sessions REST API provides information about iSCSI initiators that have successfully logged in to ONTAP.\n\n### Learn More\n* _IP Interfaces_ found in the _networking_ section. IP interfaces are the logical endpoints for iSCSI network connections to an SVM.\n\n---\n\n## Initiator Groups\nAn initiator group (igroup) is a collection of Fibre Channel WWPNs (world wide port names), iSCSI IQNs (qualified names), iSCSI EUIs (extended unique identifiers), or any combination of these, that identify host initiators.<br/>\n\nInitiator groups are used to control which hosts can access specific LUNs. To grant access to a LUN from one or more hosts, a network administrator creates an initiator group containing the hosts' initiator names, and then creates a LUN map that associates the initiator group with the LUN.<br/>\n\nThe initator group REST API allows you to create, update, delete, and discover initiator groups. It also enables you to add and remove initiators that can access the target and associated LUNs.\n\n## LUN Maps\nA LUN map is an association between a LUN and an initiator group. When a LUN is mapped to an initiator group, the group's initiators are granted access to the LUN. The relationship between an initiator group and a LUN is many initiator groups to many LUNs.<br/>\n\nThe LUN map REST API allows you to create, delete, and discover LUN maps.\n\n## LUNs\nA LUN is the logical representation of storage in a storage area network (SAN).<br/>\n\nThe LUN REST API allows you to create, update, delete, and discover LUNs.\n"
        },
        "operations": []
    },
    "NVMe": {
        "tagDetails": {
            "name": "NVMe",
            "description": "Manages resources for Non-Volatile Memory Express (NVMe)",
            "x-ntap-long-description": "## Overview\n\nThe Non-Volatile Memory Express (NVMe) API endpoints and objects provide for configuration, provisioning and management of the NVMe-related objects.\n\nNVMe over Fabrics (NVMe-oF) refers to the extensions and changes to the base NVMe command set to support NVMe commands over a fabric interconnect and from multiple hosts simultaneously. ONTAP implements elements of both NVMe and NVMe-oF. Throughout this documentation, NVMe is generally used to refer to both NVMe and NVMe-oF.\n\n### Fibre Channel Logins\nFibre Channel logins represent connections, formed by Fibre Channel initiators, that have successfully logged in to ONTAP. This represents the Fibre Channel login on which higher-level protocols such as Fibre Channel Protocol (FCP) and Non-Volatile Memory Express over Fibre Channel (NVMe over FC) rely.<br/>\n\nThe Fibre Channel logins REST API provides information about active Fibre Channel logins.\n\n### NVMe Interfaces\nNVMe interfaces are network interfaces configured to support an NVMe over Fabrics protocol. The NVMe interfaces are Fibre Channel interfaces supporting an NVMe-oF data protocol. Regardless of the underlying physical and data protocol, NVMe interfaces are treated equally for the host-side application configuration. This endpoint provides a consolidated view of all NVMe interfaces for the purpose of configuring host-side applications.<br/>\n\nThe NVMe interfaces REST API provides NVMe-specific information about network interfaces configured to support an NVMe-oF protocol.\n\n#### Learn More\n* _Fibre Channel Interfaces_ found in the _networking_ section. Fibre Channel interfaces are the logical endpoints for Fibre Channel network connections to an SVM.\n\n### NVMe Services\nA Non-Volatile Memory Express (NVMe) service defines the properties of the NVMe controller target for an SVM. There can be at most one NVMe service for a given SVM. An SVM's NVMe service must be created before NVMe host initiators can connect to the SVM.<br/>\n\nThe Non-Volatile Memory Express (NVMe) service REST API allows you to create, update, delete, and discover NVMe services for SVMs.\n\n### NVMe Subsystem Controllers\nNon-Volatile Memory Express (NVMe) subsystem controllers represent dynamic connections between hosts and a storage solution.<br/>\n\nThe NVMe subsystem controllers REST API provides information about connected hosts.\n\n### NVMe Subsystem Maps\nAn NVMe subsystem map is an association of an NVMe namespace with an NVMe subsystem. When an NVMe namespace is mapped to an NVMe subsystem, the NVMe subsystem's hosts are granted access to the NVMe namespace. The relationship between an NVMe subsystem and an NVMe namespace is one subsystem to many namespaces.<br/>\n\nThe NVMe subsystem map REST API allows you to create, delete, and discover NVMe subsystem maps.\n\n### NVMe Subsystems\nAn NVMe subsystem maintains configuration state and namespace access control for a set of NVMe-connected hosts.<br/>\n\nThe NVMe subsystem REST API allows you to create, update, delete, and discover NVMe subsystems. It also allows you to add and remove NVMe hosts that can access the subsystem and associated namespaces.\n\n### NVMe Namespaces\nAn NVMe namespace is a collection of addressable logical blocks presented to hosts connected to the storage virtual machine using the NVMe over Fabrics protocol.<br/>\n\nThe NVMe namespace REST API allows you to create, update, delete, and discover NVMe namespaces.\n"
        },
        "operations": []
    },
    "application": {
        "tagDetails": {
            "name": "application",
            "description": "Manages applications",
            "x-ntap-long-description": "## Overview\nONTAP application APIs simplify storage management by using terminology specific to a type of application. This application-specific terminology can be used to provision and manage ONTAP storage objects. A single call using application-specific parameters provisions storage and enables protocol access for an application following NetApp best practices. You can view and manage the ONTAP objects making up the application as a group using the application APIs. The library of available application templates already includes several database and virtualization applications.\n\n## APIs\n\nThere are several application APIs that must be used to fully manage an application. Templates are used to represent any parameters specific to a given application. Some APIs expose applications in terms of their specific template, while others only expose a generic view that all applications share. The template view is present on the _templates_ and _applications_ APIs (although these APIs do also include some generic fields). The _components_ and _snapshots_ APIs are entirely generic and do not differ across types of applications.\n<br/>The following section provides an overview of each API, followed by a lifecycle example of managing an application to demonstrate how the APIs can be used together.\n\n***\n### Template\nA template is an ONTAP representation of a specific type of application. Each template represents one type of application, the parameters that can be used to customize it, the layout of its storage, and how it can be accessed. Templates are intended to expose an application in terms specifically applicable to an administrator of a given application. As such, traditional ONTAP storage elements are generally not included in an application template.\n<br/>The template APIs can be used to discover what templates are currently available. The ONTAP API documentation also includes a model of the templates. The template APIs generally provide the same information as the documentation, but the template APIs might provide more up-to-date details about the default values of template parameters based on the current ONTAP configuration. However, only the ONTAP API documentation includes a full description of each template parameter, its usage, and whether it is optional.\n***\n### Application\nThe application APIs are the only interfaces that allow management of an application using template properties.\n<br/>The application object includes the following three sections:\n\n1. Generic metadata about the application, including common fields such as the name of the application, the template used to provision it, and the generation number of the application.\n2. Statistics information about the application, including space and IOPS details about the entire application and each of its components. These are expensive to collect and should only be requested when needed using a _fields=_ query.\n3. A template view of the application. The application object itself presents a mutually exclusive list of all possible templates. Only one of these fields can be used per application. The name of the field corresponds to the name of the template used by the application. Currently, the creation of a new application and the modification of the storage service for an existing application are supported through the template parameters.\n***\n### Component\nThe component API offers a generic view of the application and how to access the application from the host application. This is the only API that exposes the underlying ONTAP storage elements of which the application is composed. It is read-only; it cannot support modifications specific to the type of application it is presenting.\n<br/>The component object includes the following details for an application:\n\n1. The NFS export rules for accessing the application from the host.\n2. The CIFS share and users that can access the application from the host.\n3. The SAN initiators that can access the application from the host.\n4. For IP-based protocols, the IP addresses that are best suited for accessing the component.\n5. The underlying storage elements that make up the component, such as volumes or LUNs.\n\n***\n### Snapshot copy\nThe Snapshot copy APIs offer full CRUD for application-level Snapshot copies. Application Snapshot copies can be flagged as either crash-consistent or application-consistent. From the perspective of ONTAP, there is no difference between the two. It is the responsibility of the administrator to ensure that the application is in a consistent state before flagging a Snapshot copy as application-consistent. Use of the SnapCenter Backup Management suite is recommended to ensure correct interaction between host applications and ONTAP.\n***\n## Example\n\nThe following example outlines the APIs necessary to manage applications and how they fit together. However, this example does not provide detailed information on each API. See the documentation for the individual APIs for more information.\n\n### 1) Discover the templates\n\nThis documentation, which includes the model of each template as part of the _templates_ and _applications_ APIs, is the easiest and most comprehensive way to discover the available templates. The _templates_ API can also be used to query the system for templates in a programmatic way.<br/>\n\nTo discover the templates available to provision an Oracle application, the following query is used.\n---\n```\n# The API:\n/api/application/templates\n\n# The query:\nname=oracle*\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/application/templates?name=oracle*\" -H \"accept: application/json\"\n\n# The response:\n{\n  \"records\": [\n    {\n      \"name\": \"oracle_on_nfs\", \"description\": \"Oracle using NFS.\"\n    },\n    {\n      \"name\": \"oracle_on_san\", \"description\": \"Oracle using SAN.\"\n    },\n    {\n      \"name\": \"oracle_rac_on_nfs\", \"description\": \"Oracle RAC using NFS.\"\n    },\n    {\n      \"name\": \"oracle_rac_on_san\", \"description\": \"Oracle RAC using SAN.\"\n    }\n  ],\n  \"num_records\": 4\n}\n```\n---\n\n### 2) Create an application\n\nNow that we know the possible templates, we use one to create an application. The template properties differ from template to template, and can be found by exploring the model of the application object in this documentation. Each call to create an application must include the properties for exactly one template. These properties are provided under the property with the same name as the template. Other than the template properties, the only other required properties to create an application are the SVM and name.\n<br/>Note: In the following call example, not all of the template properties are included. Where a property is not needed or the default is sufficient, the property can be excluded. In this case using the _oracle_on_nfs_ template, the _archive_log_, and _protection_type_ are not included. The template name, _oracle_on_nfs_, is specified above the group of template properties, after the names of the application and the SVM.\n<br/>Creating an application is asynchronous, so the response for this API includes information about the job doing the work. The response header also includes the _location_ of where the application can be found if the job is successful.\n\n---\nPrior to creating an application, the following prerequisites must be met for the protocols associated with the template:\n* Licences must be installed.\n  * [`POST /cluster/licensing/licenses`](#cluster/license_create)\n* Aggregates must exist with enough available space and IOPS to satisfy the requested size.\n  * [`POST /storage/aggregates`](#storage/aggregate_create)\n* An SVM must exist with protocol services enabled.\n  * [`POST /svm/svms`](#svm/svm_create)\n* LIFs must exist. For SAN applications, only High Availability groups where each node has at least on LIF will be considered for placement of storage objects.\n  * [`POST /network/ip/interfaces`](#networking/network_ip_interfaces_create)\n  * [`POST /network/fc/interfaces`](#networking/fc_interface_create)\n---\nThe following are not required prior to creating an application, but might be necessary before connecting to the application:\n* Network routes must be created to access ethernet based LIFs.\n  * [`POST /network/ip/routes`](#networking/network_ip_routes_create)\n* For volumes created by this operation to be successfully mounted, ONTAP requirements related to mounting must be met.\n---\n```\n# The API:\n/api/application/applications\n\n# The query:\nNo query is needed for this command. Optionally, you can specify the return_timeout or set the return_records flag to alter the behavior of the command.\n\n# The body:\n{\n  \"name\": \"my_ora_app\",\n  \"svm\": {\n    \"name\": \"svm1\"\n  },\n  \"oracle_on_nfs\": {\n    \"db\": {\n      \"size\": \"2GB\",\n      \"storage_service\": {\n        \"name\": \"value\"\n      },\n      \"nfs_access\": [\n          {\n              \"access\": \"rw\",\n              \"host\": \"0.0.0.0/0\"\n          }\n      ]\n    },\n    \"redo_log\": {\n      \"size\": \"1GB\"\n    },\n    \"ora_home\": {\n      \"size\": \"1GB\"\n    }\n  }\n}\n\n# The call:\n      curl -X POST \"https://<mgmt-ip>/api/application/applications\" -H \"accept: application/hal+json\" -H \"content-type: application/json\" -d '{ \"name\": \"my_ora_app\", \"svm\": { \"name\": \"vs1\" }, \"oracle_on_nfs\": { \"db\": { \"size\": \"2GB\", \"storage_service\": { \"name\": \"value\" }, \"nfs_access\": [ { \"access\": \"rw\", \"host\": \"0.0.0.0/0\" } ] }, \"redo_log\": { \"size\": \"1GB\" }, \"ora_home\": { \"size\": \"1GB\" } } }'\n\n# The response:\n{\n  \"job\": {\n    \"uuid\": \"dc0d01dd-df5a-11e7-b5d2-005056b47eb2\",\n    \"id\": 94,\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2\"\n      }\n    }\n  }\n}\n\n# The response header:\ndate: Tue, 12 Dec 2017 16:38:18 GMT\nserver: libzapid-httpd\ncontent-type: application/hal+json\nlocation: /api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2\ncache-control: no-cache,no-store,must-revalidate\nconnection: Keep-Alive\nkeep-alive: timeout=5, max=100\ncontent-length: 203\n```\n---\n\n### 3) Wait for the application to be created\n\nThe call to create the application returns information about the job, including a HAL link to retrieve details about the job. The job object includes a state and a message to indicate the progress of the job. When the job is complete, and the application has been fully created, the message indicates success and the _state_ of the job property is _success_.\n<br/>For brevity purposes, the successful job response is shown here. On a real cluster, an application might take several seconds to several minutes to be created, depending on the system load. If the job is not complete, the _message_ property includes a short description on the progress of the job, and the _state_ indicates _running_.\n\n---\n```\n# The API:\n/api/cluster/jobs/{uuid}\n\n# The call, provided by the HAL link from step 3:\ncurl -X GET \"https://<mgmt-ip>/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2\" -H \"accept: application/hal+json\"\n\n# The response:\n{\n  \"uuid\": \"dc0d01dd-df5a-11e7-b5d2-005056b47eb2\",\n  \"state\": \"success\",\n  \"message\": \"Complete: Success [0]\",\n  \"code\": 0,\n  \"_links\": {\n    \"self\": {\n      \"href\": \"/api/cluster/jobs/dc0d01dd-df5a-11e7-b5d2-005056b47eb2\"\n    }\n  }\n}\n```\n---\n\n### 4) Retrieve the new application\n\nYou can look up the application directly without listing all the applications. Use the _location_ header that is included in the response when the application is created.\n<br/>Note: The following example uses a query to retrieve only a small number of the application's properties.\n\n---\n```\n# The API:\n/api/application/applications/{uuid}\n\n# The query:\nfields=name,template.name,generation,state\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2?fields=name,template.name,generation,state\" -H \"accept: application/json\"\n\n# The response:\n{\n  \"uuid\": \"dbc10d87-df5a-11e7-b5d2-005056b47eb2\",\n  \"name\": \"my_ora_app\",\n  \"template\": { \"name\": \"oracle_on_nfs\" },\n  \"generation\": 2,\n  \"state\": \"online\"\n}\n```\n---\n\n### 5) Discover how to access the application\n\nThe components API provides information on how to access the storage that is provisioned for the application.\n<br/>For brevity, only the names of the components are requested. See the API documentation for more information on the other available fields.\n\n---\n```\n# The API:\napi/application/applications/{application.uuid}/components\n\n# The query:\nfields=name\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/components?fields=name\" -H \"accept: application/json\"\n\n# The response:\n{\n  \"records\": [\n    { \"uuid\": \"e06fb407-df5a-11e7-b5d2-005056b47eb2\", \"name\": \"db\" },\n    { \"uuid\": \"e0709732-df5a-11e7-b5d2-005056b47eb2\", \"name\": \"ora_home\" },\n    { \"uuid\": \"e07158eb-df5a-11e7-b5d2-005056b47eb2\", \"name\": \"redo_log\" }\n  ],\n  \"num_records\": 3\n}\n```\n---\n\n### 6) Update the application\n\nTo update the storage service, the same template that is used for creating the application is reused, but with only the storage_service properties set. In the generic SAN and NAS templates, the name of each component must also be specified.\n<br/>In this example, the cluster only supports the _value_ storage service, so modifications of the application to a faster storage service fail. Note how the error message indicates the parameter that caused the problem.\n<br/>Application modification, like application creation, is an asynchronous operation. If a valid command is passed, the API returns information about the job instead of an error.\n\n---\n```\n# The API:\n/api/application/applications/{uuid}\n\n# The body:\n{\n  \"oracle_on_nfs\": { \"db\": { \"storage_service\": { \"name\": \"extreme\" } } }\n}\n\n# The call:\ncurl -X PATCH \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2\" -H \"accept: application/hal+json\" -H \"content-type: application/json\" -d '{ \"oracle_on_nfs\": { \"db\": { \"storage_service\": { \"name\": \"extreme\" } } } }'\n\n# The response:\n{\n  \"error\": {\n    \"message\": \"Invalid value for parameter \\\"oracle_on_nfs.db.storage-service.name\\\": extreme. Supported values are: value.\",\n    \"code\": \"65995152\"\n  }\n}\n```\n---\n\n### 7) Manage Snapshot copies\n\nFor applications created with the _local_ _protection_type_ set to _hourly_, Snapshot copies are automatically taken every hour. These Snapshot copies can be retrieved or restored using the Snapshot copy APIs. Snapshot copies can also be taken on demand using these APIs. It is important to note that the _consistency_type_ flag of the Snapshot copy is for record-keeping only: it is the responsibility of the administrator to ensure that the application is in a consistent state prior to flagging a Snapshot copy as _application_ consistent.\n<br/>Take a Snapshot copy manually:\n\n---\n```\n# The API:\n/api/application/applications/{uuid}/snapshots\n\n# The body:\n{\n    \"name\": \"little_bobby_tables\",\n    \"consistency_type\": \"crash\"\n}\n\n# The call:\ncurl -X POST \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots\" -H \"accept: application/hal+json\" -H \"content-type: application/json\" -d '{ \"name\": \"little_bobby_tables\", \"consistency_type\": \"crash\"}'\n\n# The response:\n{}\n\n# The response header:\ndate: Tue, 12 Dec 2017 17:40:10 GMT\nserver: libzapid-httpd\ncontent-type: application/hal+json\nlocation: /api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots/dbc10d87-df5a-11e7-b5d2-005056b47eb2_13_little_bobby_tables\ncache-control: no-cache,no-store,must-revalidate\nconnection: Keep-Alive\nkeep-alive: timeout=5, max=100\ncontent-length: 3\n```\n---\n\nIn the above example, the response body is empty, and the response header includes the _location_ of the newly created Snapshot copy. By default, all POST calls return an empty body unless a job is used to process the creation asynchronously. This behavior can be changed with the query flag _return_records_.\n<br/>Restoring a Snapshot copy uses an action API. Action paths can also be performed asynchronously as jobs, as with creating or modifying an application. The response header does not include a _location_, because this action is not creating a resource.\n\n---\n```\n# The API:\n/api/application/applications/{application.uuid}/snapshots/{snapshot.uuid}/restore\n\n# The call:\ncurl -X POST \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2/snapshots/dbc10d87-df5a-11e7-b5d2-005056b47eb2_13_little_bobby_tables/restore\" -H \"accept: application/hal+json\"\n\n# The response:\n{\n  \"job\": {\n    \"uuid\": \"00e81690-df64-11e7-b5d2-005056b47eb2\",\n    \"id\": 100,\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/00e81690-df64-11e7-b5d2-005056b47eb2\"\n      }\n    }\n  }\n}\n\n# The response header:\ndate: Tue, 12 Dec 2017 17:43:46 GMT\ncache-control: no-cache,no-store,must-revalidate\nserver: libzapid-httpd\nconnection: Keep-Alive\nkeep-alive: timeout=5, max=100\ncontent-length: 204\ncontent-type: application/hal+json\n```\n---\n\n## Smart containers\nSmart containers are traditional ONTAP storage objects such as FlexVol or FlexGroup created using the application REST API.\n* NAS - FlexVolume, FlexGroup, and FlexCache objects\n* SAN - LUNs\n* NVME - Namespaces\n---\nThe benefits of creating a Smart Container are as follows:\n* ONTAP determines the best placement for the storage object based on available performance and space capacity.\n* Access controls can be optionally set.\n* Snapshot copy schedules can be optionally set.\n* A single atomic job that does all the above.\n***\nSmart containers are similar to generic enterprise applications (NAS, SAN, NVME), but with certain restrictions. Smart containers are restricted to 1 application-component. Any post-provisioning data management operations on smart containers must be performed via PATCH operations corresponding to the object created. However, the POST, GET and DELETE operations that exist for applications will also operate for smart containers.\n\n<br/>To create a Smart Container the \"smart_container:true\" parameter must be provided.<br/>\n---\nPrior to creating a smart container, the following prerequisites must be met for the protocols associated with the template:\n* Licences must be installed.\n  * [`POST /cluster/licensing/licenses`](#cluster/license_create)\n* Aggregates must exist with enough available space to satisfy the requested size.\n  * [`POST /storage/aggregates`](#storage/aggregate_create)\n* An SVM must exist with protocol services enabled.\n  * [`POST /svm/svms`](#svm/svm_create)\n* LIFs must exist. For SAN objects, only High Availability groups where each node has at least one LIF to be considered for placement of storage objects.\n  * [`POST /network/ip/interfaces`](#networking/network_ip_interfaces_create)\n  * [`POST /network/fc/interfaces`](#networking/fc_interface_create)\n---\nThe following are not required prior to creating a smart container:\n* Network routes must be created to access Ethernet-based LIFs.\n  * [`POST /network/ip/routes`](#networking/network_ip_routes_create)\n* To mount volumes by this operation successfully, all ONTAP requirements related to mounting must be met.\n***\n### Example\nThe following examples outline the APIs necessary to create a smart container. Two types of smart container creation are supported:\n* A smart container with new ONTAP storage objects as specified in the JSON body.\n* An existing ONTAP volume can be converted into a smart container (supported only on generic SAN and NVME templates).\nThis is an addendum to the example provided on how to create an application.\n```\n# The API:\n/api/application/applications\n\n# The query:\nNo query is needed for this command. Optionally, you can specify the return_timeout or set the return_records flag to alter the behavior of the command.\n\n# The body:\nCreates a smart container with new ONTAP storage objects:\n{\n  \"name\": \"my_container\",\n  \"svm\": {\n      \"name\":\"vs1\"\n  },\n  \"template\": {\n      \"name\":\"nas\"\n  },\n  \"smart_container\": \"true\"\n  \"nas\": {\n      \"application_components\": [\n          {\n              \"share_count\": \"1\",\n              \"name\": \"myVolume\",\n              \"storage_service\": {\n                  \"name\": \"value\"\n              },\n              \"total_size\": \"100mb\"\n          }\n      ]\n  }\n}\nConverting an existing volume into a smart container:\n{\n  \"name\": \"my_container\",\n  \"svm\": {\n      \"name\":\"vs1\"\n  },\n  \"template\": {\n      \"name\":\"san\"\n  },\n  \"smart_container\": \"true\"\n  \"san\": {\n      \"application_components\": [\n          {\n              \"name\": \"existingVolume\" #name of an existing volume\n          }\n      ]\n  }\n}\n\n# The call:\nCreates a smart container with new ONTAP storage objects:\ncurl -X POST \"https://<mgmt-ip>/api/application/applications\" -H \"accept: application/hal+json\" -H \"Content-Type: application/json\" -d '{\"name\": \"my_container\", \"svm\": {\"name\": \"vs1\"} , \"smart_container\": true , \"template\": {\"name\": \"nas\"} , \"nas\": {\"application_components\": [{\"share_count\": \"1\", \"name\": \"myVolume\", \"storage_service\": {\"name\": \"value\"} , \"total_size\": \"100mb\"} ] } }'\n\nConverting an existing volume into a smart container:\ncurl -X POST \"https://<mgmt-ip>/api/application/applications\" -H \"accept: application/hal+json\" -H \"Content-Type: application/json\" -d '{\"name\": \"my_container\", \"svm\": {\"name\": \"vs1\"} , \"smart_container\": true , \"template\": {\"name\": \"san\"} , \"san\": {\"application_components\": [{\"name\": \"existingVolume\"} ] } }'\n# The response:\n {\n     \"job\": {\n         \"uuid\": \"5440db05-77f0-11e9-a5a0-005056bba32f\",\n         \"_links\": {\n             \"self\": {\n                 \"href\": \"/api/cluster/jobs/5440db05-77f0-11e9-a5a0-005056bba32f\"\n             }\n         }\n     }\n }\n\n# The response header:\ndate: Tue, 23 May 2019 16:38:18 GMT\nserver: libzapid-httpd\ncontent-type: application/hal+json\nlocation: /api/application/applications/5440db05-77f0-11e9-a5a0-005056bba32f\ncache-control: no-cache,no-store,must-revalidate\nconnection: Keep-Alive\nkeep-alive: timeout=5, max=100\ncontent-length: 203\n```\n---\n\n## Smart Container Properties\nThese sections are only allowed for smart containers and will return an error when provided on traditional applications. The following is an example of the error returned:\n```\n{\n\"error\": {\n    \"message\": \"Field \\\"<field>\\\" is only supported on smart containers.\",\n    \"code\": \"65996161\"\n    }\n}\n```\n---\n\n## Updating the smart container\nA smart container can be updated to add more LUNS and/or namespaces, with the same template used to create a smart container being reused, and with the following fields set:\n* lun_count/namespace_count - represents the total number of LUNS/namespaces in the smart container.\n* os_type - represents the OS type of the new LUNS/namespaces.\n* total_size - represents the total size of the new LUNS/namespaces to be added.\n* igroup_name/subsystem - represents the igroup/subsystem mapping for the new LUNS/namespaces.\n\nUpdates are allowed only on generic SAN and NVME templates.\n\n---\n```\n# The API:\n/api/application/applications/{uuid}\n\n# The body:\n{\n  \"san\": {\n      \"application_components\": [\n          {\n              \"name\": \"myVolume\",\n              \"lun_count\": 4\n              \"total_size\": \"1gb\"\n              \"os-type\": \"linux\",\n              \"igroup_name\": \"igroup1\"\n          }\n      ]\n  }\n}\n\n# The call:\ncurl -X PATCH \"https://<mgmt-ip>/api/application/applications/dbc10d87-df5a-11e7-b5d2-005056b47eb2\" -H \"accept: application/hal+json\" -H \"content-type: application/json\" -d '{ \"san\": { \"application_components\": [{ \"name\": \"myVolume\", \"total_size\": \"1GB\", \"lun_count\": 4, \"os_type\": \"linux\", \"igroup_name\": \"igroup1\"}]}}'\n```\n## Application API limitations\n## Application API limitations\n\n### Template versus generic\n\nApplications can be represented in either template or generic terms. All applications can be represented in generic terms as a list of components. Each component generally maps to a field in the template. For example, Microsoft SQL Server applications have a component named _sqldata_ that corresponds to the _db_ parameter in the sql_on_san template. These mappings are usually straightforward and allow the templates to present application terminology, while the generic view uses the traditional naming schemes for ONTAP storage elements.\n<br/>The current release supports the creation and modification of applications in template terms, but retrieval is not supported. The mapping from template to generic terms is left to your own discretion.za\n\n### ONTAP feature support\n\nApplication APIs are interfaces layered on top of traditional ONTAP storage. While the intent is to provide a full management suite through application APIs, some features of the underlying ONTAP objects are not directly supported through application APIs. Applications are provisioned using ONTAP best practices, so the need for additional modifications of the underlying objects should be minimal. If such modifications are necessary, the traditional ONTAP APIs can be used. The _/api/application/{application.uuid}/components_ API provides a _backing_storage_ field that can be used to locate the storage objects associated with an application. This API also provides details of the NFS, CIFS, or SAN protocol access objects associated with the application.\n<br/>The application APIs use the extra information known about the application to coordinate multiple ONTAP objects in unison. When using non-application APIs, certain settings might interfere with the ONTAP object coordination and cause the application APIs to behave unexpectedly. To continue to supply the full ONTAP feature set, these modifications on the underlying objects are allowed, but there is no guarantee that these modifications will not adversely affect the application experience. You should use this feature with caution.\n"
        },
        "operations": []
    },
    "support": {
        "tagDetails": {
            "name": "support",
            "description": "Manages backups, autosupports, and event handling",
            "x-ntap-long-description": "## Overview\n\nYou can use ONTAP support APIs to manage configuration backups, autosupport settings, and event handling.\n\n### Configuration backups\n\nConfiguration backups are copies of node and cluster settings saved to an external server.\n\nSingle-node clusters must have configuration backups as protection against corruption of the configuration database. Multi-node clusters back up the configuration automatically between the nodes in the cluster.\n"
        },
        "operations": []
    },
    "security": {
        "tagDetails": {
            "name": "security",
            "description": "Manage the security settings for the cluster and SVMs",
            "x-ntap-long-description": "## Overview\n\nYou can use ONTAP security APIs to manage security settings for the cluster and SVMs.\n\n### SAML\nConfigure the SAML 2.0 SP (Service Provider) protocol inside ONTAP. Doing so redirects the authentication task to a third-party Identity Provider (IDP) that can utilize any number of approaches for multi-factor authentication. After SAML authentication is enabled, all interactive web access (System Manager, SPI) is authenticated via SAML and a third-party IDP.\n"
        },
        "operations": []
    },
    "storage": {
        "tagDetails": {
            "name": "storage",
            "description": "Manages physical and logical storage",
            "x-ntap-long-description": "## Overview\n\nThe ONTAP storage APIs can be used to manage physical and logical storage. This includes management of aggregates, volumes, LUNs, qtrees, snapshots, quotas, and storage effeciency.\n<br/>\n"
        },
        "operations": [{
            "path": "/storage/volumes",
            "method": "x-ntap-long-description",
            "operation": {
                "tags": ["storage"],
                "description": "## Overview\nFlexVol volumes are logical containers used by ONTAP to serve data to clients.  They contain file systems in a NAS environment and LUNs in a SAN environment.<br/>\nA FlexGroup volume is a scale-out NAS container that provides high performance along with automatic load distribution and scalability. A FlexGroup volume contains several constituents that automatically and transparently share the traffic.</br>\nFlexClone volumes are writable, point-in-time copies of a FlexVol volume. At this time, FlexClones of FlexGroups are not supported.<br/>\nVolumes with SnapLock type Compliance or Enterprise, are referred to as SnapLock volumes. Volumes with SnapLock type cannot be of FlexGroup style. Once a SnapLock aggregate is created, by default, volumes created inside the aggregate inherit the \"snaplock\" property from the aggregate. It is possible to create a SnapLock volume by specifying SnapLock parameters. SnapLock parameters are only available at the \"advanced\" privilege level.<br/>\nONTAP storage APIs allow you to create, modify, and monitor volumes and aggregates.<br/>\n\n## Storage efficiency\nStorage efficiency is used to remove duplicate blocks in the data and to compress the data. Efficiency has deduplication, compression, cross volume deduplication, and compaction options. On All Flash systems, all efficiencies are enabled by default on volume creation. Options such as \"background/inline/both\" are treated as both, which means both background and inline are enabled for any efficiency option. The option \"none\"  disables both background and inline efficiency.<br/>\nTo enable any efficiency option on all-flash or FAS systems, background deduplication is always enabled.<br/>\n\n## Quotas\nQuotas provide a way to restrict or track the files and space usage by a user, group, or qtree. Quotas are enabled for a specific FlexVol or a FlexGroup volume.<br/>\nThe following APIs can be used to enable or disable and obtain quota state for a FlexVol or a FlexGroup volume:\n\n&ndash; PATCH  /api/storage/volumes/{uuid} -d '{\"quota.enabled\":\"true\"}'\n&ndash; PATCH  /api/storage/volumes/{uuid} -d '{\"quota.enabled\":\"false\"}'\n&ndash; GET    /api/storage/volumes/{uuid}/?fields=quota.state\n\n## File System Analytics\nFile system analytics provide a quick method for obtaining information summarizing properties of all files within any directory tree of a volume. For more information on file system analytics, see [`DOC /storage/volumes{volume.uuid}/files/{path}`](#docs-storage-storage_volumes_{volume.uuid}_files_{path}). Analytics can be enabled or disabled on individual volumes.<br/>\nThe following APIs can be used to enable or disable and obtain analytics state for a FlexVol volume or a FlexGroup volume:\n\n&ndash; PATCH  /api/storage/volumes/{uuid} -d '{\"analytics.state\":\"on\"}'\n&ndash; PATCH  /api/storage/volumes/{uuid} -d '{\"analytics.state\":\"off\"}'\n&ndash; GET    /api/storage/volumes/{uuid}/?fields=analytics\n\n## QoS\nQoS policy and settings enforce Service Level Objectives (SLO) on a volume. SLO can be set by specifying qos.max_throughput_iops and/or qos.max_throughput_mbps or qos.min_throughput_iops. Specifying min_throughput_iops is only supported on volumes hosted on a node that is flash optimized. A pre-created QoS policy can also be used by specifying qos.name or qos.uuid property. <br/>\n\n## Performance monitoring\nPerformance of a volume can be monitored by the `metric.*` and `statistics.*` fields. These show the performance of the volume in terms of IOPS, latency and throughput. The `metric.*` fields denote an average whereas `statistics.*` fields denote a real-time monotonically increasing value aggregated across all nodes. <br/>\n\n## Volume APIs\nThe following APIs are used to perform operations related with FlexVol volumes and FlexGroup volumes:\n\n&ndash; POST      /api/storage/volumes\n&ndash; GET       /api/storage/volumes\n&ndash; GET       /api/storage/volumes/{uuid}\n&ndash; PATCH     /api/storage/volumes/{uuid}\n&ndash; DELETE    /api/storage/volumes/{uuid}\n\n## Examples\n### Creating a volume\nThe POST request is used to create a new volume and to specify its properties.\n```\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X POST  \"https://<mgmt-ip>/api/storage/volumes\" -H \"accept: application/hal+json\" -d '{\"name\": \"vol1\", \"aggregates\":[{\"name\":\"aggr1\"}], \"svm\":{\"name\" : \"vs1\"}}'\n\n# The response:\n{\n  \"job\": {\n    \"uuid\": \"b89bc5dd-94a3-11e8-a7a3-0050568edf84\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/b89bc5dd-94a3-11e8-a7a3-0050568edf84\"\n      }\n    }\n  }\n}\n```\n\n### Creating a SnapLock volume and specifying its properties using POST\n```\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X POST  \"https://<mgmt-ip>/api/storage/volumes\" -H \"accept: application/hal+json\" -d '{\"name\": \"vol1\",  \"aggregates\":[{\"name\": \"aggr1\"}],  \"svm\":{\"name\" : \"vs1\"}, \"snaplock\":{\"retention\":{\"default\": \"P20Y\"}}}'\n\n# The response:\n{\n  \"job\": {\n    \"uuid\": \"e45b123b-c228-11e8-aa20-0050568e36bb\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/e45b123b-c228-11e8-aa20-0050568e36bb\"\n      }\n    }\n  }\n}\n```\n\n### Creating a FlexGroup volume and specifying its properties using POST\n```\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X POST  \"https://<mgmt-ip>/api/storage/volumes\" -H \"accept: application/hal+json\" -d '{\"name\" : \"vol1\", \"state\" : \"online\", \"type\" : \"RW\", \"aggregates\" : [{\"name\" : \"aggr1\"}, {\"name\" : \"aggr2\"}, {\"name\":\"aggr3\"}], \"constituents_per_aggregate\" : \"1\", \"svm\" : {\"name\" : \"vs1\"}, \"size\" : \"240MB\", \"encryption\" : {\"enabled\" : \"False\"}, \"efficiency\" : {\"compression\" : \"both\"}, \"autosize\" : {\"maximum\" : \"500MB\", \"minimum\" : \"240MB\"}}'\n\n# The response:\n{\n  \"job\": {\n    \"uuid\": \"3cfa38bd-3a78-11e9-ae39-0050568ed7dd\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/3cfa38bd-3a78-11e9-ae39-0050568ed7dd\"\n      }\n    }\n  }\n}\n```\n\n### Creating a FlexClone and specifying its properties using POST\n```\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X POST  \"https://<mgmt-ip>/api/storage/volumes\" -H \"accept: application/hal+json\" -d '{\"name\":\"vol1_clone\", \"clone\": {\"parent_volume\": {\"name\": \"vol1\"}, \"is_flexclone\": \"true\"},\"svm\":{\"name\": \"vs0\"}}'\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Tue, 26 Feb 2019 09:06:22 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nLocation: /api/storage/volumes/?name=vol1_clone\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"c9ee0040-39a5-11e9-9b24-00a098439a83\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/c9ee0040-39a5-11e9-9b24-00a098439a83\"\n      }\n    }\n  }\n}\n```\n\n## Volumes reported in the GET REST API\n### The following types of volumes are reported:\n&ndash;  RW, DP and LS volume\n&ndash;  FlexGroup volume\n&ndash;  FlexCache volume\n&ndash;  FlexClone volume\n<br/>\n\n### The following types of volumes are not reported:\n&ndash;  DEL volume\n&ndash;  TEMP volume\n&ndash;  Node Root volume\n&ndash;  System Vserver volume\n&ndash;  FlexGroup constituent\n&ndash;  FlexCache constituent\n\n## Examples\n### Retrieving the list of volumes\n```\n\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/storage/volumes\" -H \"accept: application/hal+json\"\n\n# The response:\n{\n  \"records\": [\n    {\n      \"uuid\": \"2d1167cc-c3f2-495a-a23f-8f50b071b9b8\",\n      \"name\": \"vsdata_root\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/storage/volumes/2d1167cc-c3f2-495a-a23f-8f50b071b9b8\"\n        }\n      }\n    },\n    {\n      \"uuid\": \"3969be7e-78b4-4b4c-82a4-fa86331f03df\",\n      \"name\": \"vsfg_root\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/storage/volumes/3969be7e-78b4-4b4c-82a4-fa86331f03df\"\n        }\n      }\n    },\n    {\n      \"uuid\": \"59c03ac5-e708-4ce8-a676-278dc249fda2\",\n      \"name\": \"svm_root\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/storage/volumes/59c03ac5-e708-4ce8-a676-278dc249fda2\"\n        }\n      }\n    },\n    {\n      \"uuid\": \"6802635b-8036-11e8-aae5-0050569503ac\",\n      \"name\": \"fgvol\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/storage/volumes/6802635b-8036-11e8-aae5-0050569503ac\"\n        }\n      }\n    },\n    {\n      \"uuid\": \"d0c3359c-5448-4a9b-a077-e3295a7e9057\",\n      \"name\": \"datavol\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\"\n        }\n      }\n    }\n  ],\n  \"num_records\": 5,\n  \"_links\": {\n    \"self\": {\n      \"href\": \"/api/storage/volumes\"\n    }\n  }\n}\n```\n\n### Retrieving the attributes of a volume\nThe GET request is used to retrieve the attributes of a volume.\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -H \"accept: application/hal+json\"\n\n# The response:\n{\n  \"uuid\": \"d0c3359c-5448-4a9b-a077-e3295a7e9057\",\n  \"comment\": \"This is a data volume\",\n  \"create_time\": \"2018-07-05T14:56:44+05:30\",\n  \"language\": \"en_us\",\n  \"name\": \"datavol\",\n  \"size\": 20971520,\n  \"state\": \"online\",\n  \"style\": \"flexvol\",\n  \"tiering_policy\": \"auto\",\n  \"type\": \"rw\",\n  \"aggregates\": [\n    {\n      \"name\": \"data\",\n      \"uuid\": \"aa742322-36bc-4d98-bbc4-0a827534c035\",\n      \"_links\": {\n        \"self\": {\n          \"href\": \"/api/cluster/aggregates/data\"\n        }\n      }\n    }\n  ],\n  \"encryption\": {\n    \"enabled\": false,\n    \"state\": \"none\",\n    \"key_id\": \"\",\n    \"type\" : \"none\"\n  },\n  \"error_state\": {\n    \"has_bad_blocks\": false,\n    \"is_inconsistent\": false\n  },\n  \"files\": {\n    \"maximum\": 566,\n    \"used\": 96\n  },\n  \"nas\": {\n    \"gid\": 2468,\n    \"security_style\": \"unix\",\n    \"uid\": 1357,\n    \"unix_permissions\": 4755,\n    \"export_policy\": {\n      \"name\": \"default\",\n      \"id\": 8589934593\n    }\n  },\n  \"metric\": {\n    \"timestamp\": \"2019-04-09T05:50:15Z\",\n    \"status\": \"ok\",\n    \"duration\": \"PT15S\",\n    \"latency\": {\n      \"other\": 0,\n      \"total\": 0,\n      \"read\": 0,\n      \"write\": 0\n    },\n    \"iops\": {\n      \"read\": 0,\n      \"write\": 0,\n      \"other\": 0,\n      \"total\": 0\n    },\n    \"throughput\": {\n      \"read\": 0,\n      \"write\": 0,\n      \"other\": 0,\n      \"total\": 0\n    },\n    \"cloud\": {\n      \"timestamp\": \"2019-04-09T05:50:15Z\",\n      \"status\": \"ok\",\n      \"duration\": \"PT15S\",\n      \"iops\" : {\n        \"read\": 0,\n        \"write\": 0,\n        \"other\": 0,\n        \"total\": 0\n      },\n      \"latency\": {\n        \"read\": 0,\n        \"write\": 0,\n        \"other\": 0,\n        \"total\": 0\n      }\n    },\n    \"flexcache\": {\n      \"timestamp\": \"2019-04-09T05:50:15Z\",\n      \"status\": \"ok\",\n      \"duration\": \"PT1D\",\n      \"cache_miss_percent\": 0\n    }\n  },\n  \"statistics\": {\n    \"timestamp\": \"2019-04-09T05:50:42Z\",\n    \"status\": \"ok\",\n    \"latency_raw\": {\n      \"other\": 38298,\n      \"total\": 38298,\n      \"read\": 0,\n      \"write\": 0\n    },\n    \"iops_raw\": {\n      \"read\": 0,\n      \"write\": 0,\n      \"other\": 3,\n      \"total\": 3\n    },\n    \"throughput_raw\": {\n      \"read\": 0,\n      \"write\": 0,\n      \"other\": 0,\n      \"total\": 0\n    },\n    \"cloud\": {\n      \"timestamp\": \"2019-04-09T05:50:42Z\",\n      \"status\": \"ok\",\n      \"iops_raw\" : {\n        \"read\": 0,\n        \"write\": 0,\n        \"other\": 0,\n        \"total\": 0\n      },\n      \"latency_raw\": {\n        \"read\": 0,\n        \"write\": 0,\n        \"other\": 0,\n        \"total\": 0\n      }\n    },\n    \"flexcache_raw\": {\n      \"timestamp\": \"2019-04-09T05:50:15Z\",\n      \"status\": \"ok\",\n      \"cache_miss_blocks\": 0,\n      \"client_requested_blocks\": 0\n    }\n  },\n  \"qos\": {\n    \"policy\": {\n    \"min_throughput_iops\": 0,\n    \"max_throughput_iops\": 1000,\n    \"max_throughput_mbps\": 0,\n    \"uuid\": \"228454af-5a8b-11e9-bd5b-005056ac6f1f\",\n    \"name\": \"pg1\"\n    }\n  },\n  \"snaplock\": {\n    \"append_mode_enabled\": false,\n    \"autocommit_period\": \"none\",\n    \"compliance_clock_time\": \"2019-05-24T10:59:00+05:30\",\n    \"expiry_time\": \"2038-01-19T08:44:28+05:30\",\n    \"is_audit_log\": false,\n    \"litigation_count\": 0,\n    \"privileged_delete\": \"disabled\",\n    \"type\": \"enterprise\",\n    \"retention\": {\n      \"default\": \"P0Y\",\n      \"minimum\": \"P0Y\",\n      \"maximum\": \"P30Y\"\n    }\n  },\n  \"snapshot_policy\": {\n    \"name\": \"default\"\n  },\n  \"svm\": {\n    \"name\": \"vsdata\",\n    \"uuid\": \"d61b69f5-7458-11e8-ad3f-0050569503ac\"\n  },\n  \"_links\": {\n    \"self\": {\n      \"href\": \"/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\"\n    }\n  }\n}\n```\n\n### Retrieving the quota state of a FlexVol or a FlexGroup volume\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X GET \"https://<mgmt-ip>/api/storage/volumes/cb20da45-4f6b-11e9-9a71-005056a7f717/?fields=quota.state\" -H \"accept: application/hal+json\"\n\n# The response:\n{\n  \"uuid\": \"cb20da45-4f6b-11e9-9a71-005056a7f717\",\n  \"name\": \"fv\",\n  \"quota\": {\n    \"state\": \"on\"\n  },\n  \"_links\": {\n    \"self\": {\n      \"href\": \"/api/storage/volumes/cb20da45-4f6b-11e9-9a71-005056a7f717/\"\n    }\n  }\n}\n```\n## Updating the attributes of a volume\n\n## Examples\n### Updating the attributes of a volume\nThe PATCH request is used to update the attributes of a volume.\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{ \"size\": 26214400, \"nas\": {\"security_style\": \"mixed\"}, \"comment\": \"This is a data volume\" }' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Tue, 31 Jul 2018 09:36:43 GMT\nServer: libzapid-httpd\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"3c5be5a6-94a5-11e8-8ca3-00505695c11b\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/3c5be5a6-94a5-11e8-8ca3-00505695c11b\"\n      }\n    }\n  }\n}\n```\n\n### Updating the attributes of a FlexClone using PATCH\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{\"clone\":{\"split_initiated\":\"true\"}}' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Mon, 25 Feb 2019 10:10:19 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"8e01747f-38e5-11e9-8a3a-00a09843994b\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/8e01747f-38e5-11e9-8a3a-00a09843994b\"\n      }\n    }\n  }\n}\n```\n\n### Enabling quotas for a FlexVol or a FlexGroup volume using PATCH\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{\"quota\":{\"enabled\":\"true\"}}' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Mon, 25 Feb 2019 10:10:19 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"d2fe7299-57d0-11e9-a2dc-005056a7f717\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/d2fe7299-57d0-11e9-a2dc-005056a7f717\"\n      }\n    }\n  }\n}\n```\n\n### Disabling quotas for a FlexVol or a FlexGroup volume using PATCH\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{\"quota\":{\"enabled\":\"false\"}}' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Mon, 25 Feb 2019 10:10:19 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"0c8f6bea-57d1-11e9-a2dc-005056a7f717\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/0c8f6bea-57d1-11e9-a2dc-005056a7f717\"\n      }\n    }\n  }\n}\n```\n\n## Add tiering object tags for a FlexVol using PATCH\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{\"tiering.object_tags\": [ \"key1=val1\", \"key2=val2\" ]}' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Tue, 11 Feb 2020 19:29:25 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"d05012de-4d04-11ea-836b-005056bb6f9d\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/d05012de-4d04-11ea-836b-005056bb6f9d\"\n      }\n    }\n  }\n}\n```\n\n### Remove tiering object tags for a FlexVol using PATCH\n```\n# The API:\n/api/storage/volumes/{uuid}\n\n# The call:\ncurl -X PATCH  \"https://<mgmt-ip>/api/storage/volumes/d0c3359c-5448-4a9b-a077-e3295a7e9057\" -d '{\"tiering.object_tags\": []}' -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\nDate: Fri, 24 Jan 2020 22:28:04 GMT\nServer: libzapid-httpd\nX-Content-Type-Options: nosniff\nCache-Control: no-cache,no-store,must-revalidate\nContent-Length: 189\nContent-Type: application/hal+json\n\n{\n  \"job\": {\n    \"uuid\": \"ca234df1-3ef8-11ea-9a56-005056bb69a1\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/ca234df1-3ef8-11ea-9a56-005056bb69a1\"\n      }\n    }\n  }\n}\n```\n\n## Deleting a volume\n\n## Example\n### Deleting a volume\nThe DELETE request is used to delete a volume.\n```\n# The API:\n/api/storage/volumes\n\n# The call:\ncurl -X DELETE  \"https://<mgmt-ip>/api/storage/volumes/{uuid} \" -H \"accept: application/hal+json\"\n\n# The response:\nHTTP/1.1 202 Accepted\ncache-control: no-cache,no-store,must-revalidate\nconnection: Keep-Alive\ncontent-length: 189\ncontent-type: application/json\ndate: Wed, 01 Aug 2018 09:40:36 GMT\nkeep-alive: timeout=5, max=100\nserver: libzapid-httpd\n{\n  \"job\": {\n    \"uuid\": \"f1aa3eb8-956e-11e8-86bf-0050568e2249\",\n    \"_links\": {\n      \"self\": {\n        \"href\": \"/api/cluster/jobs/f1aa3eb8-956e-11e8-86bf-0050568e2249\"\n      }\n    }\n  }\n}\n```\n",
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "x-ntap-long-description-/storage/volumes"
        }, {
            "path": "/storage/volumes",
            "method": "get",
            "operation": {
                "tags": ["storage"],
                "description": "Retrieves volumes.\n\n### Expensive properties\nThere is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.\n* `is_svm_root`\n* `analytics.*`\n* `application.*`\n* `encryption.*`\n* `clone.parent_snapshot.name`\n* `clone.parent_snapshot.uuid`\n* `clone.parent_svm.name`\n* `clone.parent_svm.uuid`\n* `clone.parent_volume.name`\n* `clone.parent_volume.uuid`\n* `clone.split_complete_percent`\n* `clone.split_estimate`\n* `clone.split_initiated`\n* `efficiency.*`\n* `error_state.*`\n* `files.*`\n* `nas.export_policy.id`\n* `nas.gid`\n* `nas.path`\n* `nas.security_style`\n* `nas.uid`\n* `nas.unix_permissions`\n* `snaplock.*`\n* `restore_to.*`\n* `snapshot_policy.uuid`\n* `quota.*`\n* `qos.*`\n* `flexcache_endpoint_type`\n* `space.block_storage_inactive_user_data`\n* `space.capacity_tier_footprint`\n* `space.performance_tier_footprint`\n* `space.local_tier_footprint`\n* `space.footprint`\n* `space.over_provisioned`\n* `space.metadata`\n* `space.total_footprint`\n* `space.logical_space.*`\n* `space.snapshot.*`\n* `guarantee.*`\n* `autosize.*`\n* `movement.*`\n* `statistics.*`\n\n### Related ONTAP commands\n* `volume show`\n* `volume clone show`\n* `volume efficiency show`\n* `volume encryption show`\n* `volume flexcache show`\n* `volume flexgroup show`\n* `volume move show`\n* `volume quota show`\n* `volume show-space`\n* `volume snaplock show`\n",
                "operationId": "volume_collection_get",
                "parameters": [{
                    "x-ntap-autogen-params": "volume"
                }, {
                    "$ref": "#/parameters/fields_param"
                }, {
                    "$ref": "#/parameters/max_records_param"
                }, {
                    "$ref": "#/parameters/return_records_get_param"
                }, {
                    "$ref": "#/parameters/return_timeout_get_param"
                }, {
                    "$ref": "#/parameters/order_by_param"
                }],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/volume_response"
                        }
                    },
                    "default": {
                        "description": "Error",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "get-/storage/volumes"
        }, {
            "path": "/storage/volumes",
            "method": "post",
            "operation": {
                "tags": ["storage"],
                "description": "Creates a volume on a specified SVM and storage aggregates.\n\n### Required properties\n* `svm.uuid` or `svm.name` - Existing SVM in which to create the volume.\n* `name` - Name of the volume.\n* `aggregates.name` or `aggregates.uuid` - Existing aggregates in which to create the volume.\n\n### Default property values\n* `state` -  _online_\n* `size` - _20MB_\n* `style` - _flexvol_\n* `type` - _rw_\n* `encryption.enabled` - _false_\n* `snapshot_policy.name` - _default_\n* `gaurantee.type` - _volume_\n\n### Related ONTAP commands\n* `volume create`\n* `volume clone create`\n",
                "operationId": "volume_create",
                "parameters": [{
                    "name": "info",
                    "required": true,
                    "in": "body",
                    "description": "Info specification",
                    "schema": {
                        "$ref": "#/definitions/volume"
                    }
                }],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/job_link_response"
                        }
                    },
                    "default": {
                        "description": "- x-ntap-error-table-start: volume_errors.et,aggr_msgs.et,vserver_errors.et,analytics_errors.et\n- name: VOLUME_FIELD_NOT_ALLOWED\n  message: The target field cannot be specified for this operation.\n- name: VSERVER_REST_POST_NO_SVM\n  message: No SVM was specified. Either \\\"svm.name\\\" or \\\"svm.uuid\\\" must be supplied.\n- name: VOLUME_REST_CLONE_CREATE_INVALID_OPTION\n  message: Specifying a value is not valid for a volume FlexClone creation.\n- name: VOLUME_REST_NO_CLONE_PARENT_VOL\n  message: \\\"volume.clone.parent_volume.name\\\" or \\\"volume.clone.parent_volume.uuid\\\" must be provided.\n- name: VSERVER_UUID_NAME_MISMATCH\n  message: The specified \\\"svm.uuid\\\" and \\\"svm.name\\\" do not refer to the same SVM.\n- name: VOLUME_UUID_NAME_MISMATCH\n  message: The specified \\\"parent_volume.uuid\\\" and \\\"parent_volume.name\\\" do not refer to the same volume.\n- name: VOLUME_CLONE_SNAPSHOT_NAME_UUID_MISMATCH\n  message: The specified Snapshot copy UUID is not correct for the specified Snapshot copy name.\n- name: VOLUME_REST_INVALID_CLONE_TYPE\n  message: Invalid \\\"volume.type\\\" for clone volume.\n- name: VOLUME_REST_UNSUPPORTED_FLEXVOL_CONFIG\n  message: When creating a flexible volume, exactly one aggregate must be specified via either \\\"aggregates.name\\\" or \\\"aggregates.uuid\\\".\n- name: VOLUME_REST_UNSUPPORTED_VOLUME_STYLE\n  message: The target style is an unsupported volume style for volume creation.\n- name: VOLUME_REST_INVALID_VOLUME_STYLE\n  message: The target style is an invalid volume style.\n- name: AGGREGATE_REST_POST_NO_AGGR\n  message: One of \\\"aggregates.uuid\\\", \\\"aggregates.name\\\", or \\\"style\\\" must be provided.\n- name: AGGREGATE_UUID_NAME_MISMATCH\n  message: The specified \\\"aggregates.name\\\" and \\\"aggregates.uuid\\\" refer to different aggregates.\n- name: VOLUME_REST_INVALID_PATH\n  message: \\\"nas.path\\\" is invalid.\n- name: VOLUME_EXCEEDS_MAXIMUM_ALLOWED\n  message: Maximum allowed snapshot.reserve_percent value during a volume creation is 90. Use PATCH to set it to a higher value after the volume has been created.\n- name: ANALYTICS_NO_CAPABILITY\n  message: File system analytics requires an effective cluster version of 9.8 or later.\n- name: ANALYTICS_INVALID_STATE_FOR_CREATE_MODIFY\n  message: The specified \\\"analytics.state\\\" is invalid.\n- name: ANALYTICS_LUNS_NOT_SUPPORTED\n  message: File system analytics cannot be enabled on volumes that contain LUNs.\n- name: VOLUME_TIER_MIN_COOL_DAYS_MIXED_VERSION\n  message: Flexvol tiering min cooling days requires an effective cluster version of ONTAP 9.4 or later.\n- name: VOLUME_TIER_MIN_COOL_DAYS_NOT_SUPPORTED_SVMDR\n  message: Tiering min cooling days not supported for SVMDR.\n- name: VOLUME_TIER_MIN_COOL_DAYS_ON_NON_DATA_VOLUME\n  message: Tiering min cooling days not supported for non data volumes.\n- name: VOLUME_TIER_MIN_COOL_DAYS_INVALID_TIERING_POLICY\n  message: Tiering min cooling days not allowed for the provided tiering policy.\n- name: VOLUME_FG_TIER_MIN_COOL_DAYS_MODIFY_MIXED_VERSION\n  message: FlexGroup tiering min cooling days requires an effective cluster version of ONTAP 9.5 or later.\n- name: VOLUME_CLOUD_RETRIEVE_POLICY_MIXED_VERSION\n  message: cloud retrieval policy requires an effective cluster version of 9.8 or later.\n- name: VOLUME_CLOUD_RETRIEVE_POLICY_NOT_SUPPORTED\n  message: Invalid volume cloud retrieval policy for the provided tiering policy.\n- name: VOLUME_CLOUD_RETRIEVE_POLICY_ON_NON_DATA_VOLUME\n  message: cloud retrieval policy not supported for non data volume.\n- name: VOLUME_DUPLICATE_VOLUME_NAME\n  message: The volume name specified is a duplicate.\n- name: VOLUME_AUTOSIZE_MAX_INVALID_VAL\n  message: The volume maximum autosize must be smaller than or equal to the maximum volume size.\n- name: VOLUME_AUTOSIZE_MAX_MIN_INVALID\n  message: Volume minimum autosize must be smaller than the maximum autosize.\n- name: VOLUME_AUTOSIZE_GS_THRESHOLDS_INVALID\n  message: Volume autosize grow threshold must be larger than autosize shrink threshold.\n- name: VOLUME_AUTOSIZE_MIN_INVALID_VAL\n  message: Volume minimum autosize must be less than or equal to the current volume size.\n- x-ntap-error-table-end: END\n",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "post-/storage/volumes"
        }, {
            "path": "/storage/volumes/{uuid}",
            "method": "get",
            "operation": {
                "tags": ["storage"],
                "description": "Retrieves a volume. The GET API can be used to retrieve the quota state for a FlexVol or a FlexGroup volume.\n\n### Expensive properties\nThere is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the `fields` query parameter. See [`Requesting specific fields`](#Requesting_specific_fields) to learn more.\n* `is_svm_root`\n* `analytics.*`\n* `application.*`\n* `encryption.*`\n* `clone.parent_snapshot.name`\n* `clone.parent_snapshot.uuid`\n* `clone.parent_svm.name`\n* `clone.parent_svm.uuid`\n* `clone.parent_volume.name`\n* `clone.parent_volume.uuid`\n* `clone.split_complete_percent`\n* `clone.split_estimate`\n* `clone.split_initiated`\n* `efficiency.*`\n* `error_state.*`\n* `files.*`\n* `nas.export_policy.id`\n* `nas.gid`\n* `nas.path`\n* `nas.security_style`\n* `nas.uid`\n* `nas.unix_permissions`\n* `snaplock.*`\n* `restore_to.*`\n* `snapshot_policy.uuid`\n* `quota.*`\n* `qos.*`\n* `flexcache_endpoint_type`\n* `space.block_storage_inactive_user_data`\n* `space.capacity_tier_footprint`\n* `space.performance_tier_footprint`\n* `space.local_tier_footprint`\n* `space.footprint`\n* `space.over_provisioned`\n* `space.metadata`\n* `space.total_footprint`\n* `space.logical_space.*`\n* `space.snapshot.*`\n* `guarantee.*`\n* `autosize.*`\n* `movement.*`\n* `statistics.*`\n\n### Related ONTAP commands\n* `volume show`\n* `volume clone show`\n* `volume efficiency show`\n* `volume encryption show`\n* `volume flexcache show`\n* `volume flexgroup show`\n* `volume move show`\n* `volume quota show`\n* `volume show-space`\n* `volume snaplock show`\n",
                "operationId": "volume_get",
                "parameters": [{
                    "name": "uuid",
                    "in": "path",
                    "type": "string",
                    "description": "Unique identifier of the volume.",
                    "required": true
                }, {
                    "$ref": "#/parameters/fields_param"
                }],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/volume"
                        }
                    },
                    "default": {
                        "description": "Error",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "get-/storage/volumes/{uuid}"
        }, {
            "path": "/storage/volumes/{uuid}",
            "method": "patch",
            "operation": {
                "tags": ["storage"],
                "description": "Updates the attributes of a volume. For movement, use the \"validate_only\" field on the request to validate but not perform the operation. The PATCH API can be used to enable or disable quotas for a FlexVol or a FlexGroup volume. An empty path in PATCH deactivates and unmounts the volume. Taking a volume offline removes its junction path.\n<br>A PATCH request for volume encryption performs conversion/rekey operations asynchronously. You can retrieve the conversion/rekey progress details by calling a GET request on the corresponding volume endpoint.\n\n### Optional properties\n* `queue_for_encryption` - Queue volumes for encryption when `encryption.enabled=true`.  If this option is not provided or is false, conversion of volumes starts immediately. When there are volumes in the queue and less than four encryptions are running, volumes are encrypted in the order in which they are queued.\n\n### Related ONTAP commands\n* `volume unmount`\n* `volume mount`\n* `volume online`\n* `volume offline`\n* `volume modify`\n* `volume clone modify`\n* `volume efficiency modify`\n* `volume quota on`\n* `volume quota off`\n* `volume snaplock modify`\n* `volume encryption conversion start`\n* `volume encryption rekey start`\n",
                "operationId": "volume_modify",
                "parameters": [{
                    "name": "uuid",
                    "in": "path",
                    "description": "Unique identifier of the volume.",
                    "type": "string",
                    "required": true
                }, {
                    "name": "restore_to.snapshot.uuid",
                    "in": "query",
                    "description": "UUID of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.",
                    "type": "string"
                }, {
                    "name": "restore_to.snapshot.name",
                    "in": "query",
                    "description": "Name of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.",
                    "type": "string"
                }, {
                    "name": "sizing_method",
                    "in": "query",
                    "description": "Represents the method to modify the size of a Flexgroup. The following methods are supported:\n* use_existing_resources - Increases or decreases the size of the FlexGroup by increasing or decreasing the size of the current FlexGroup resources\n* add_new_resources - Increases the size of the FlexGroup by adding new resources\n",
                    "type": "string",
                    "enum": ["use_existing_resources", "add_new_resources"],
                    "default": "use_existing_resources"
                }, {
                    "$ref": "#/parameters/validate_only_param"
                }, {
                    "name": "info",
                    "in": "body",
                    "description": "Info specification",
                    "schema": {
                        "$ref": "#/definitions/volume"
                    }
                }],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/job_link_response"
                        }
                    },
                    "default": {
                        "description": "- x-ntap-error-table-start: olv_errors.et,volume_errors.et,aggr_msgs.et,analytics_errors.et\n- name: OLV_REST_CANNOT_ADD_NEW_RESOURCE_TO_FLEXVOL\n  message: Resizing by adding new resources is only supported for FlexGroups.\n- name: OLV_REST_CANNOT_MANUAL_EXPAND_AND_RESIZE\n  message: When adding new resources to a FlexGroup by specifying \\\"aggregates.name\\\" or \\\"aggregates.uuid\\\", the FlexGroup cannot be resized using \\\"size\\\". These operations must be done separately.\n- name: OLV_REST_CANNOT_AUTO_EXPAND\n  message: When adding new resources to a FlexGroup using \\\"sizing_method\\\", \\\"size\\\" must be specified.  Neither \\\"aggregates.name\\\" nor \\\"aggregates.uuid\\\" are allowed to be specified, as the aggregates are selected automatically by the system.\n- name: AGGREGATE_UUID_NAME_MISMATCH\n  message: The specified \\\"aggregates.name\\\" and \\\"aggregates.uuid\\\" refer to different aggregates.\n- name: VOLUME_REST_AGGREGATE_STATE_MUTUALLY_EXCLUSIVE\n  message: \\\"movement.destination_aggregate\\\" and \\\"movement.state\\\" are mutually exclusive, unless the state is \\\"cutover-wait\\\".\n- name: VOLUME_REST_AGGREGATE_NOT_EXIST\n  message: The specified \\\"movement.destination_aggregate\\\" does not exist.\n- name: VOLUME_REST_VOLUME_SAME_AGGREGATE\n  message: Volume is on the same aggregate.\n- name: VOLUME_REST_CLONE_SPLIT_INVALID_OPTION\n  message: Specifying a value is not valid for initiating volume FlexClone split operation.\n- name: VOLUME_REST_SNAP_RESTORE_INVALID_OPTION\n  message: Specifying a value is not valid for a Snapshot copy restore operation.\n- name: VOLUME_REST_INVALID_PATH\n  message: specified \\\"nas.path\\\" is invalid.\n- name: ANALYTICS_CANT_ENABLE\n  message: File system analytics cannot be enabled on the target volume because of the specified reason.\n- name: ANALYTICS_CANT_DISABLE\n  message: File system analytics cannot be disabled on the target volume because of the specified reason.\n- name: ANALYTICS_NO_CAPABILITY\n  message: File system analytics requires an effective cluster version of 9.8 or later.\n- name: ANALYTICS_INVALID_STATE_FOR_CREATE_MODIFY\n  message: The specified \\\"analytics.state\\\" is invalid.\n- name: ANALYTICS_LUNS_NOT_SUPPORTED\n  message: File system analytics cannot be enabled on volumes that contain LUNs.\n- name: VOLUME_CANNOT_MODIFY_TIER_MIN_COOL_DAYS_DURING_VOLMOVE\n  message: Cannot modify tiering min cooling days when vol move is in progress.\n- name: VOLUME_TIER_MIN_COOL_DAYS_NOT_SUPPORTED_SVMDR\n  message: Tiering min cooling days not supported for SVMDR.\n- name: VOLUME_TIER_MIN_COOL_DAYS_ON_NON_DATA_VOLUME\n  message: Tiering min cooling days not supported for non data volumes.\n- name: VOLUME_TIER_MIN_COOL_DAYS_INVALID_TIERING_POLICY\n  message: Tiering min cooling days not allowed for the provided tiering policy.\n- name: VOLUME_CLOUD_RETRIEVE_POLICY_NOT_SUPPORTED\n  message: Invalid volume cloud retrieval policy for the provided tiering policy.\n- name: VOLUME_CLOUD_RETRIEVE_POLICY_ON_NON_DATA_VOLUME\n  message: cloud retrieval policy not supported for non data volume.\n- name: VOLUME_CANNOT_MODIFY_CLOUD_RETRIEVE_POLICY_DURING_VOLMOVE\n  message: Cannot modify cloud retrieval policy when vol move is in progress.\n- name: VOLUME_AUTOSIZE_MAX_INVALID_VAL\n  message: The volume maximum autosize must be smaller than or equal to the maximum volume size.\n- name: VOLUME_AUTOSIZE_MAX_MIN_INVALID\n  message: Volume minimum autosize must be smaller than the maximum autosize.\n- name: VOLUME_AUTOSIZE_GS_THRESHOLDS_INVALID\n  message: Volume autosize grow threshold must be larger than autosize shrink threshold.\n- x-ntap-error-table-end: END\n",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "patch-/storage/volumes/{uuid}"
        }, {
            "path": "/storage/volumes/{uuid}",
            "method": "delete",
            "operation": {
                "tags": ["storage"],
                "description": "Deletes a volume. If the UUID belongs to a volume, all of its blocks are freed and returned to its containing aggregate. If a volume is online, it is offlined before deletion. If a volume is mounted, unmount the volume by specifying the nas.path as empty before deleting it using the DELETE operation.\n\n### Related ONTAP commands\n* `volume delete`\n* `volume clone delete`\n",
                "operationId": "volume_delete",
                "parameters": [{
                    "name": "uuid",
                    "in": "path",
                    "description": "Unique identifier of the volume.",
                    "required": true,
                    "type": "string"
                }],
                "responses": {
                    "202": {
                        "description": "Accepted",
                        "schema": {
                            "$ref": "#/definitions/job_link_response"
                        }
                    },
                    "default": {
                        "description": "Error",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "delete-/storage/volumes/{uuid}"
        }, {
            "path": "/storage/volumes/{volume.uuid}/metrics",
            "method": "get",
            "operation": {
                "tags": ["storage"],
                "description": "Retrieves historical performance metrics for a volume.",
                "operationId": "volume_metrics_collection_get",
                "parameters": [{
                    "x-ntap-autogen-params": "volume_metrics"
                }, {
                    "$ref": "#/parameters/return_timeout_get_param"
                }, {
                    "$ref": "#/parameters/fields_param"
                }, {
                    "$ref": "#/parameters/max_records_param"
                }, {
                    "$ref": "#/parameters/order_by_param"
                }, {
                    "$ref": "#/parameters/return_records_get_param"
                }, {
                    "name": "volume.uuid",
                    "in": "path",
                    "type": "string",
                    "description": "Unique identifier of the volume.",
                    "required": true
                }, {
                    "name": "interval",
                    "in": "query",
                    "type": "string",
                    "description": "The time range for the data. Examples can be 1h, 1d, 1m, 1w, 1y.\nThe period for each time range is as follows:\n* 1h: Metrics over the most recent hour sampled over 15 seconds.\n* 1d: Metrics over the most recent day sampled over 5 minutes.\n* 1w: Metrics over the most recent week sampled over 30 minutes.\n* 1m: Metrics over the most recent month sampled over 2 hours.\n* 1y: Metrics over the most recent year sampled over a day.\n",
                    "enum": ["1h", "1d", "1w", "1m", "1y"],
                    "default": "1h"
                }],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/volume_metrics_response"
                        }
                    },
                    "default": {
                        "description": "Error",
                        "schema": {
                            "$ref": "#/definitions/error_response"
                        }
                    }
                },
                "consumes": ["application/json", "application/hal+json"],
                "produces": ["application/json", "application/hal+json"]
            },
            "id": "get-/storage/volumes/{volume.uuid}/metrics"
        }]
    },
    "snapmirror": {
        "tagDetails": {
            "name": "snapmirror",
            "description": "Manages asynchronous extended data protection (XDP) relationships for FlexVols, FlexGroups, or SVMs",
            "x-ntap-long-description": "## Overview\nSnapMirror technology enables customers to copy and backup their production data. The secondary or destination volume in such a backup relationship can reside anywhere, locally or remotely, and can be used to restore access to the protected data. You can restore access to protected data by drawing upon a vault of backups or, in the event that a primary is unusable, by using a disaster recovery copy that can be activated for clients and applications. SnapMirror periodically updates a replica to create new backups and/or to keep a replica up-to-date with changes that have been written to the primary. The SnapMirror subsystems are designed to keep many pairs of source (primary) and destination (secondary) copies up-to-date in an efficient and scalable manner. <br/>\nThe SnapMirror APIs can be used to create and manage SnapMirror relationships of type \"async\", and \"sync\". These APIs can also be used to manage restore-relationships. These APIs allow you to manage the following endpoints:\n\n* SnapMirror policies - When applied to a SnapMirror relationship, the SnapMirror policy controls the behavior of the relationship and specifies the configuration attributes for that relationship.\n* SnapMirror relationships - You can create and manage SnapMirror relationships, and you can change the state of the SnapMirror relationship using a PATCH request.\n* SnapMirror transfers - You can manage data transfers on the specified SnapMirror relationship.\n"
        },
        "operations": []
    },
    "ndmp": {
        "tagDetails": {
            "name": "ndmp",
            "description": "Manages NDMP services",
            "x-ntap-long-description": "NDMP (Network Data Management Protocol) provides an open standard for network-based backup of network-attached storage (NAS). NDMP minimizes the coding required for different applications by providing standard commands for backing up and restoring file servers. NDMP increases the speed and efficiency of NAS data protection, as data can bypass backup servers and be written directly to tape storage. Starting from ONTAP 8.2, the software supports SVM aware NDMP backups. This helps in optimizing NDMP backup performance by choosing efficient data transfer paths and is fully compatible with integrated non-disruptive operations and volume mobility capabilities of ONTAP software. In order to support this feature, a CAB extension must be implemented by backup vendors.\n\nThese APIs allow you to manage the following endpoints:\n\n* ndmp\n* ndmp nodes\n* ndmp svms\n* ndmp sessions\n\n## APIs\n\n### NDMP\n\nThese APIs are used to manage NDMP mode, SVM-scope or node-scope.\n\n### NDMP nodes\n\nThese APIs are used to manage node configurations.\n\n### NDMP SVMs\n\nThese APIs are used to manage NDMP configurations of SVMs.\n\n### NDMP sessions\n\nThese APIs are used to manage diagnostic information on NDMP sessions belonging to a specific SVM in the case of SVM-scope or to a specific node in the case of node-scope.\n"
        },
        "operations": []
    },
    "snaplock": {
        "tagDetails": {
            "name": "snaplock",
            "description": "SnapLock is a high-performance compliance solution that uses WORM storage to retain files in an unmodified form.",
            "x-ntap-long-description": "SnapLock is an alternative to the traditional optical \"write once, read many\" (WORM) data. SnapLock is used for the storage of read-only WORM data. SnapLock is a license-based, disk-based, open-protocol feature that works with application software to administer non-rewritable storage of data. The primary objective of this feature is to provide storage-enforced WORM and retention functionality. SnapLock can be deployed for protecting data in strict regulatory environments in such a way that even the storage administrator is considered an untrusted party. SnapLock provides special purpose volumes in which files can be stored and committed to a non-erasable, non-rewritable state either forever or for a designated retention period. SnapLock allows this retention to be performed at the granularity of individual files.\nThese APIs allow you to manage the following endpoints:\n\n* SnapLock log\n* SnapLock compliance-clock\n* SnapLock event-retention\n* SnapLock file retention\n* SnapLock privileged-delete\n* SnapLock file fingerprint\n* SnapLock legal-hold\n\n## APIs\n\n###  SnapLock log\n\nThese APIs are used to create and initialize the SnapLock log configuration for an SVM, modify attributes associated with the SnapLock log configuration,and delete the auditlog configuration.\n\n###  SnapLock compliance-clock\n\nThis API  manages the ComplianceClock of the system. ComplianceClock determines the expiry time of the SnapLock objects in the system. ComplianceClock can be initialized only once by the user and once it is set, it cannot be changed or altered by the user.\n\n### SnapLock event-retention\n\nThis API is used to create Event Based Retention (EBR) policies for an SVM. A policy consists of a policy-name and a retention-period. Only a user with security login role vsadmin-snaplock is allowed to perform this operation.\n\n### SnapLock file retention\n\nThis API is used to set the retention time of a file. Retention time expects the date in ISO 8601 format or \"infinite\".\n\n### SnapLock privileged-delete\n\nThis API is used to perform a privileged-delete operation on unexpired WORM files on a SnapLock Enterprise volume. The only built-in role that has access to the command is \"vsadmin-snaplock\".\n\n### SnapLock file fingerprint\n\nThis API is used to start the fingerprint computation on a file.\n\n### SnapLock legal-hold\n\nThis API is used to retain Compliance-mode WORM files for the duration of a litigation. A file under a Legal-Hold behaves like a WORM file with an indefinite retention period. Only a user with security login role vsadmin-snaplock is allowed to perform the operation.\n"
        },
        "operations": []
    },
    "NAS": {
        "tagDetails": {
            "name": "NAS",
            "description": "Manages the NFS and export settings for clusters and SVMs",
            "x-ntap-long-description": "## Overview\nThese APIs allow you to complete various tasks, including:\n\n* Creating an NFS server for an SVM\n* Managing an NFS configuration of an SVM\n* Viewing and updating the NFS configuration of an SVM\n* Configuring export policies and rules for an SVM\n* Managing export policies and rules for an SVM\n\n## APIs\n\n### NFS\nThe NFS APIs enable you to create and configure NFS settings for an SVM. You can delete or update NFS configurations, and you can also disable or enable different NFS features as needed.\n\nThe export APIs allow you to create and manage export policies for an SVM that enable an administrator to restrict access to volumes for clients that match specific IP addresses and specific authentication types. Export APIs are also used to create export rules for an export policy. The APIs allow each rule to specify the number of mask bits in the client IP address that must be matched for that rule to apply to a particular client request. The APIs also allow each export rule to specify the authentication types that are required for both read-only and read-write operations.\n\n### Kerberos\nKerberos is a protocol designed to provide strong authentication for users and hosts within a client/server environment. The basis of the protocol is a shared, secret-key cryptology system. (Kerberos uses shared-key encryption to ensure the confidentiality of the data. It also uses hashing techniques to ensure the integrity of the data (so that no one can modify the data unless allowed to do so). With the NetApp multiprotocol storage platform, through which clients based on UNIX or Windows can access data using CIFS or NFS, it is crucial to provide the ability to use standard network services for authentication and for identity storage.<br/>\n\nTo configure an ONTAP system to use Kerberos for NFS, Kerberos must be enabled on a data LIF in the SVM that owns the NFS server. A Kerberos realm needs to be created before enabling Kerberos on a data LIF. (The Kerberos realm is needed so that the cluster knows how to format Kerberos ticket requests.) The Kerberos APIs allow you to define, create, modify, and delete realms for the SVM. The APIs also allow you to enable/disable Kerberos on a data LIF and update the Kerberos interface configuration for a particular data LIF in the SVM.\n"
        },
        "operations": []
    }
}